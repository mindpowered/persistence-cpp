// Generated by Haxe 4.1.1
#include <hxcpp.h>

#ifndef INCLUDED_869a921fcf5bba54
#define INCLUDED_869a921fcf5bba54
#include "maglev/MagLevAny.h"
#endif
#ifndef INCLUDED_20db69a30a45e926
#define INCLUDED_20db69a30a45e926
#include "maglev/MagLevArray.h"
#endif
#ifndef INCLUDED_35ec03520fbb0747
#define INCLUDED_35ec03520fbb0747
#include "maglev/MagLevBoolean.h"
#endif
#ifndef INCLUDED_d8a74f90a5c0b964
#define INCLUDED_d8a74f90a5c0b964
#include "maglev/MagLevError.h"
#endif
#ifndef INCLUDED_7f9204b932c8d809
#define INCLUDED_7f9204b932c8d809
#include "maglev/MagLevFunction.h"
#endif
#ifndef INCLUDED_ba46386e6aba7150
#define INCLUDED_ba46386e6aba7150
#include "maglev/MagLevNull.h"
#endif
#ifndef INCLUDED_95fa5e9194badcf5
#define INCLUDED_95fa5e9194badcf5
#include "maglev/MagLevNumber.h"
#endif
#ifndef INCLUDED_f4da16f85a617f60
#define INCLUDED_f4da16f85a617f60
#include "maglev/MagLevObject.h"
#endif
#ifndef INCLUDED_65acb6100057af6e
#define INCLUDED_65acb6100057af6e
#include "maglev/MagLevResult.h"
#endif
#ifndef INCLUDED_c859d2752ef86c43
#define INCLUDED_c859d2752ef86c43
#include "maglev/MagLevString.h"
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_persistence_MagLevConverter
#include <persistence/MagLevConverter.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_20a371823f0e41b4_14_convertToHaxe,"persistence.MagLevConverter","convertToHaxe",0x593b046d,"persistence.MagLevConverter.convertToHaxe","persistence/MagLevConverter.hx",14,0x208943d8)
HX_LOCAL_STACK_FRAME(_hx_pos_20a371823f0e41b4_53_convertToHaxe,"persistence.MagLevConverter","convertToHaxe",0x593b046d,"persistence.MagLevConverter.convertToHaxe","persistence/MagLevConverter.hx",53,0x208943d8)
HX_LOCAL_STACK_FRAME(_hx_pos_20a371823f0e41b4_73_convertToMagLev,"persistence.MagLevConverter","convertToMagLev",0x55d04711,"persistence.MagLevConverter.convertToMagLev","persistence/MagLevConverter.hx",73,0x208943d8)
HX_LOCAL_STACK_FRAME(_hx_pos_20a371823f0e41b4_89_convertToMagLev,"persistence.MagLevConverter","convertToMagLev",0x55d04711,"persistence.MagLevConverter.convertToMagLev","persistence/MagLevConverter.hx",89,0x208943d8)
namespace persistence{

void MagLevConverter_obj::__construct() { }

Dynamic MagLevConverter_obj::__CreateEmpty() { return new MagLevConverter_obj; }

void *MagLevConverter_obj::_hx_vtable = 0;

Dynamic MagLevConverter_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< MagLevConverter_obj > _hx_result = new MagLevConverter_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool MagLevConverter_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x03c35d1f;
}

 ::Dynamic MagLevConverter_obj::convertToHaxe( ::maglev::MagLevAny x){
            	HX_GC_STACKFRAME(&_hx_pos_20a371823f0e41b4_14_convertToHaxe)
HXDLIN(  14)		int _hx_tmp = x->getType();
HXDLIN(  14)		if ((_hx_tmp == ::maglev::MagLevNull_obj::getStaticType())) {
HXLINE(  15)			return null();
            		}
            		else {
HXLINE(  17)			int _hx_tmp = x->getType();
HXDLIN(  17)			if ((_hx_tmp == ::maglev::MagLevBoolean_obj::getStaticType())) {
HXLINE(  18)				 ::maglev::MagLevBoolean y = ::hx::TCast<  ::maglev::MagLevBoolean >::cast(x);
HXLINE(  19)				return y->getBool();
            			}
            			else {
HXLINE(  21)				int _hx_tmp = x->getType();
HXDLIN(  21)				if ((_hx_tmp == ::maglev::MagLevString_obj::getStaticType())) {
HXLINE(  22)					 ::maglev::MagLevString y = ::hx::TCast<  ::maglev::MagLevString >::cast(x);
HXLINE(  23)					return y->getString();
            				}
            				else {
HXLINE(  25)					int _hx_tmp = x->getType();
HXDLIN(  25)					if ((_hx_tmp == ::maglev::MagLevNumber_obj::getStaticType())) {
HXLINE(  26)						 ::maglev::MagLevNumber y = ::hx::TCast<  ::maglev::MagLevNumber >::cast(x);
HXLINE(  27)						return y->getFloat();
            					}
            					else {
HXLINE(  29)						int _hx_tmp = x->getType();
HXDLIN(  29)						if ((_hx_tmp == ::maglev::MagLevArray_obj::getStaticType())) {
HXLINE(  30)							 ::maglev::MagLevArray y = ::hx::TCast<  ::maglev::MagLevArray >::cast(x);
HXLINE(  31)							::cpp::VirtualArray arr = ::cpp::VirtualArray_obj::__new();
HXLINE(  32)							int i = 0;
HXLINE(  33)							while((i < y->size())){
HXLINE(  34)								arr->push(::persistence::MagLevConverter_obj::convertToHaxe(y->get(i)));
HXLINE(  35)								i = (i + 1);
            							}
HXLINE(  37)							return arr;
            						}
            						else {
HXLINE(  39)							int _hx_tmp = x->getType();
HXDLIN(  39)							if ((_hx_tmp == ::maglev::MagLevObject_obj::getStaticType())) {
HXLINE(  40)								 ::maglev::MagLevObject y = ::hx::TCast<  ::maglev::MagLevObject >::cast(x);
HXLINE(  41)								 ::haxe::ds::StringMap map =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  42)								 ::maglev::MagLevArray keys = y->keys();
HXLINE(  43)								int i = 0;
HXLINE(  44)								while((i < keys->size())){
HXLINE(  45)									::String key = ::hx::TCast<  ::maglev::MagLevString >::cast(keys->get(i))->getString();
HXLINE(  46)									map->set(key,::persistence::MagLevConverter_obj::convertToHaxe(y->get(key)));
HXLINE(  47)									i = (i + 1);
            								}
HXLINE(  49)								return map;
            							}
            							else {
HXLINE(  51)								int _hx_tmp = x->getType();
HXDLIN(  51)								if ((_hx_tmp == ::maglev::MagLevFunction_obj::getStaticType())) {
            									HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::maglev::MagLevFunction,y) HXARGC(1)
            									 ::Dynamic _hx_run(::cpp::VirtualArray args){
            										HX_GC_STACKFRAME(&_hx_pos_20a371823f0e41b4_53_convertToHaxe)
HXLINE(  54)										 ::maglev::MagLevArray arr = ::maglev::MagLevArray_obj::create();
HXLINE(  55)										{
HXLINE(  55)											int _g = 0;
HXDLIN(  55)											while((_g < args->get_length())){
HXLINE(  55)												 ::Dynamic arg = args->__get(_g);
HXDLIN(  55)												_g = (_g + 1);
HXLINE(  56)												arr->push(::persistence::MagLevConverter_obj::convertToMagLev(arg));
            											}
            										}
HXLINE(  58)										 ::maglev::MagLevResult ret = y->call(arr);
HXLINE(  59)										if (ret->isError()) {
HXLINE(  60)											HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(ret->getError()->getMessage()));
            										}
            										else {
HXLINE(  62)											return ::persistence::MagLevConverter_obj::convertToHaxe(ret->getResult());
            										}
HXLINE(  59)										return null();
            									}
            									HX_END_LOCAL_FUNC1(return)

HXLINE(  52)									 ::maglev::MagLevFunction y = ::hx::TCast<  ::maglev::MagLevFunction >::cast(x);
HXLINE(  53)									 ::Dynamic f =  ::Dynamic(new _hx_Closure_0(y));
HXLINE(  65)									return f;
            								}
            								else {
HXLINE(  68)									HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("convertToHaxe: unknown type",4a,83,07,f2)));
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  14)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MagLevConverter_obj,convertToHaxe,return )

 ::maglev::MagLevAny MagLevConverter_obj::convertToMagLev( ::Dynamic x){
            	HX_STACKFRAME(&_hx_pos_20a371823f0e41b4_73_convertToMagLev)
HXDLIN(  73)		if (::hx::IsNull( x )) {
HXLINE(  74)			return ::maglev::MagLevNull_obj::create();
            		}
            		else {
HXLINE(  76)			if (::Std_obj::isOfType(x,( ( ::Dynamic)(::hx::ClassOf< bool >()) ))) {
HXLINE(  77)				return ::maglev::MagLevBoolean_obj::fromBool(::hx::TCast< bool >::cast(x));
            			}
            			else {
HXLINE(  79)				if (::Std_obj::isOfType(x,( ( ::Dynamic)(::hx::ClassOf< ::String >()) ))) {
HXLINE(  80)					return ::maglev::MagLevString_obj::fromString(::hx::TCast< ::String >::cast(x));
            				}
            				else {
HXLINE(  82)					if (::Std_obj::isOfType(x,( ( ::Dynamic)(::hx::ClassOf< int >()) ))) {
HXLINE(  83)						return ::maglev::MagLevNumber_obj::fromInt(::hx::TCast< int >::cast(x));
            					}
            					else {
HXLINE(  85)						if (::Std_obj::isOfType(x,( ( ::Dynamic)(::hx::ClassOf< ::Float >()) ))) {
HXLINE(  86)							return ::maglev::MagLevNumber_obj::fromFloat(( (Float)(x) ));
            						}
            						else {
HXLINE(  88)							if (::Reflect_obj::isFunction(x)) {
            								HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::Dynamic,x) HXARGC(1)
            								 ::maglev::MagLevResult _hx_run( ::maglev::MagLevArray args){
            									HX_STACKFRAME(&_hx_pos_20a371823f0e41b4_89_convertToMagLev)
HXLINE(  90)									 ::Dynamic y = x;
HXLINE(  91)									 ::Dynamic haxeArgs = ::persistence::MagLevConverter_obj::convertToHaxe(args);
HXLINE(  92)									 ::Dynamic haxeRet = y(haxeArgs);
HXLINE(  93)									return ::maglev::MagLevResult_obj::fromResult(::persistence::MagLevConverter_obj::convertToMagLev(haxeRet));
            								}
            								HX_END_LOCAL_FUNC1(return)

HXLINE(  89)								 ::Dynamic f =  ::Dynamic(new _hx_Closure_0(x));
HXLINE(  95)								return ::maglev::MagLevFunction_obj::fromFunction(f);
            							}
            							else {
HXLINE(  97)								if (::Std_obj::isOfType(x,( ( ::Dynamic)(::hx::ArrayBase::__mClass) ))) {
HXLINE(  98)									 ::maglev::MagLevArray arr = ::maglev::MagLevArray_obj::create();
HXLINE(  99)									::cpp::VirtualArray y = ( (::cpp::VirtualArray)(x) );
HXLINE( 100)									{
HXLINE( 100)										int _g = 0;
HXDLIN( 100)										while((_g < y->get_length())){
HXLINE( 100)											 ::Dynamic item = y->__get(_g);
HXDLIN( 100)											_g = (_g + 1);
HXLINE( 101)											arr->push(::persistence::MagLevConverter_obj::convertToMagLev(item));
            										}
            									}
HXLINE( 103)									return arr;
            								}
            								else {
HXLINE( 105)									if (::Std_obj::isOfType(x,( ( ::Dynamic)(::hx::ClassOf< ::haxe::ds::StringMap >()) ))) {
HXLINE( 106)										 ::haxe::ds::StringMap map = ( ( ::haxe::ds::StringMap)(x) );
HXLINE( 107)										 ::maglev::MagLevObject obj = ::maglev::MagLevObject_obj::create();
HXLINE( 108)										{
HXLINE( 108)											 ::Dynamic key = map->keys();
HXDLIN( 108)											while(( (bool)(key->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 108)												::String key1 = ( (::String)(key->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 109)												obj->set(key1,::persistence::MagLevConverter_obj::convertToMagLev(map->get(key1)));
            											}
            										}
HXLINE( 111)										return obj;
            									}
            									else {
HXLINE( 113)										if (::Reflect_obj::isObject(x)) {
HXLINE( 114)											 ::maglev::MagLevObject obj = ::maglev::MagLevObject_obj::create();
HXLINE( 115)											{
HXLINE( 115)												int _g = 0;
HXDLIN( 115)												::Array< ::String > _g1 = ::Reflect_obj::fields(x);
HXDLIN( 115)												while((_g < _g1->length)){
HXLINE( 115)													::String field = _g1->__get(_g);
HXDLIN( 115)													_g = (_g + 1);
HXLINE( 116)													 ::Dynamic val = ::Reflect_obj::getProperty(x,field);
HXLINE( 117)													obj->set(field,::persistence::MagLevConverter_obj::convertToMagLev(val));
            												}
            											}
HXLINE( 119)											return obj;
            										}
            										else {
HXLINE( 122)											HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("convertToMagLev: unknown type",ae,84,a9,64)));
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  73)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MagLevConverter_obj,convertToMagLev,return )


MagLevConverter_obj::MagLevConverter_obj()
{
}

bool MagLevConverter_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 13:
		if (HX_FIELD_EQ(inName,"convertToHaxe") ) { outValue = convertToHaxe_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"convertToMagLev") ) { outValue = convertToMagLev_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *MagLevConverter_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *MagLevConverter_obj_sStaticStorageInfo = 0;
#endif

::hx::Class MagLevConverter_obj::__mClass;

static ::String MagLevConverter_obj_sStaticFields[] = {
	HX_("convertToHaxe",94,89,1b,b6),
	HX_("convertToMagLev",f8,a3,b9,0f),
	::String(null())
};

void MagLevConverter_obj::__register()
{
	MagLevConverter_obj _hx_dummy;
	MagLevConverter_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("persistence.MagLevConverter",87,81,09,2e);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &MagLevConverter_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(MagLevConverter_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< MagLevConverter_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = MagLevConverter_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = MagLevConverter_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace persistence
