// Generated by Haxe 4.1.1
#include <hxcpp.h>

#ifndef INCLUDED_16d41c6fc5b8bf5d
#define INCLUDED_16d41c6fc5b8bf5d
#include "maglev/MagLev.h"
#endif
#ifndef INCLUDED_869a921fcf5bba54
#define INCLUDED_869a921fcf5bba54
#include "maglev/MagLevAny.h"
#endif
#ifndef INCLUDED_20db69a30a45e926
#define INCLUDED_20db69a30a45e926
#include "maglev/MagLevArray.h"
#endif
#ifndef INCLUDED_35ec03520fbb0747
#define INCLUDED_35ec03520fbb0747
#include "maglev/MagLevBoolean.h"
#endif
#ifndef INCLUDED_d8a74f90a5c0b964
#define INCLUDED_d8a74f90a5c0b964
#include "maglev/MagLevError.h"
#endif
#ifndef INCLUDED_7f9204b932c8d809
#define INCLUDED_7f9204b932c8d809
#include "maglev/MagLevFunction.h"
#endif
#ifndef INCLUDED_ba46386e6aba7150
#define INCLUDED_ba46386e6aba7150
#include "maglev/MagLevNull.h"
#endif
#ifndef INCLUDED_95fa5e9194badcf5
#define INCLUDED_95fa5e9194badcf5
#include "maglev/MagLevNumber.h"
#endif
#ifndef INCLUDED_f4da16f85a617f60
#define INCLUDED_f4da16f85a617f60
#include "maglev/MagLevObject.h"
#endif
#ifndef INCLUDED_65acb6100057af6e
#define INCLUDED_65acb6100057af6e
#include "maglev/MagLevResult.h"
#endif
#ifndef INCLUDED_c859d2752ef86c43
#define INCLUDED_c859d2752ef86c43
#include "maglev/MagLevString.h"
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_persistence_Persistence
#include <persistence/Persistence.h>
#endif
#ifndef INCLUDED_persistence__Persistence_Getter
#include <persistence/_Persistence/Getter.h>
#endif
#ifndef INCLUDED_persistence__Persistence_Mutator
#include <persistence/_Persistence/Mutator.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_20_new,"persistence.Persistence","new",0x1c38c4a2,"persistence.Persistence.new","persistence/Persistence.hx",20,0x9767c4cf)
HX_DEFINE_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_35_new,"persistence.Persistence","new",0x1c38c4a2,"persistence.Persistence.new","persistence/Persistence.hx",35,0x9767c4cf)
HX_DEFINE_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_54_new,"persistence.Persistence","new",0x1c38c4a2,"persistence.Persistence.new","persistence/Persistence.hx",54,0x9767c4cf)
HX_DEFINE_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_61_new,"persistence.Persistence","new",0x1c38c4a2,"persistence.Persistence.new","persistence/Persistence.hx",61,0x9767c4cf)
HX_DEFINE_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_16_new,"persistence.Persistence","new",0x1c38c4a2,"persistence.Persistence.new","persistence/Persistence.hx",16,0x9767c4cf)
HX_LOCAL_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_70_addMutator,"persistence.Persistence","addMutator",0xab434ebf,"persistence.Persistence.addMutator","persistence/Persistence.hx",70,0x9767c4cf)
HX_LOCAL_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_72_addMutator,"persistence.Persistence","addMutator",0xab434ebf,"persistence.Persistence.addMutator","persistence/Persistence.hx",72,0x9767c4cf)
HX_LOCAL_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_81_addGetter,"persistence.Persistence","addGetter",0xa800a5ce,"persistence.Persistence.addGetter","persistence/Persistence.hx",81,0x9767c4cf)
HX_LOCAL_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_83_addGetter,"persistence.Persistence","addGetter",0xa800a5ce,"persistence.Persistence.addGetter","persistence/Persistence.hx",83,0x9767c4cf)
HX_LOCAL_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_86_addGetter,"persistence.Persistence","addGetter",0xa800a5ce,"persistence.Persistence.addGetter","persistence/Persistence.hx",86,0x9767c4cf)
HX_LOCAL_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_95_mutate,"persistence.Persistence","mutate",0x1e0a9484,"persistence.Persistence.mutate","persistence/Persistence.hx",95,0x9767c4cf)
HX_LOCAL_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_145_get,"persistence.Persistence","get",0x1c3374d8,"persistence.Persistence.get","persistence/Persistence.hx",145,0x9767c4cf)
HX_LOCAL_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_209_calcKey,"persistence.Persistence","calcKey",0xf23c314c,"persistence.Persistence.calcKey","persistence/Persistence.hx",209,0x9767c4cf)
HX_LOCAL_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_213_convertToHaxe,"persistence.Persistence","convertToHaxe",0x4e912456,"persistence.Persistence.convertToHaxe","persistence/Persistence.hx",213,0x9767c4cf)
HX_LOCAL_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_253_convertToHaxe,"persistence.Persistence","convertToHaxe",0x4e912456,"persistence.Persistence.convertToHaxe","persistence/Persistence.hx",253,0x9767c4cf)
HX_LOCAL_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_273_convertToMagLev,"persistence.Persistence","convertToMagLev",0xe4dcf33a,"persistence.Persistence.convertToMagLev","persistence/Persistence.hx",273,0x9767c4cf)
HX_LOCAL_STACK_FRAME(_hx_pos_9b0a59171cb4a4c9_10_boot,"persistence.Persistence","boot",0x8d8c49b0,"persistence.Persistence.boot","persistence/Persistence.hx",10,0x9767c4cf)
namespace persistence{

void Persistence_obj::__construct( ::maglev::MagLev bus){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::persistence::Persistence,_gthis) HXARGC(1)
            		 ::maglev::MagLevResult _hx_run( ::maglev::MagLevArray args){
            			HX_GC_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_20_new)
HXLINE(  21)			::String recordType = ::hx::TCast<  ::maglev::MagLevString >::cast(args->get(0))->getString();
HXLINE(  22)			::String operationName = ::hx::TCast<  ::maglev::MagLevString >::cast(args->get(1))->getString();
HXLINE(  23)			 ::persistence::Persistence _gthis1 = _gthis;
HXDLIN(  23)			 ::Dynamic strategyMethod = _gthis1->convertToHaxe(args->get(2));
HXLINE(  24)			 ::Dynamic updateMapper = null();
HXLINE(  25)			if ((args->size() > 3)) {
HXLINE(  26)				 ::persistence::Persistence _gthis1 = _gthis;
HXDLIN(  26)				updateMapper = _gthis1->convertToHaxe(args->get(3));
            			}
HXLINE(  28)			 ::Dynamic useRecordDataAsParams = null();
HXLINE(  29)			if ((args->size() > 4)) {
HXLINE(  30)				 ::persistence::Persistence _gthis1 = _gthis;
HXDLIN(  30)				useRecordDataAsParams = _gthis1->convertToHaxe(args->get(4));
            			}
HXLINE(  32)			_gthis->addMutator(recordType,operationName,strategyMethod,updateMapper,useRecordDataAsParams);
HXLINE(  33)			return ::maglev::MagLevResult_obj::fromResult(::maglev::MagLevBoolean_obj::fromBool(true));
            		}
            		HX_END_LOCAL_FUNC1(return)

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1, ::persistence::Persistence,_gthis) HXARGC(1)
            		 ::maglev::MagLevResult _hx_run( ::maglev::MagLevArray args){
            			HX_GC_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_35_new)
HXLINE(  36)			::String recordType = ::hx::TCast<  ::maglev::MagLevString >::cast(args->get(0))->getString();
HXLINE(  37)			::String operationName = ::hx::TCast<  ::maglev::MagLevString >::cast(args->get(1))->getString();
HXLINE(  38)			 ::persistence::Persistence _gthis1 = _gthis;
HXDLIN(  38)			 ::Dynamic strategyMethod = _gthis1->convertToHaxe(args->get(2));
HXLINE(  39)			 ::Dynamic queryMapper = null();
HXLINE(  40)			if ((args->size() >= 4)) {
HXLINE(  41)				 ::persistence::Persistence _gthis1 = _gthis;
HXDLIN(  41)				queryMapper = _gthis1->convertToHaxe(args->get(3));
            			}
HXLINE(  43)			 ::Dynamic resultMapper = null();
HXLINE(  44)			if ((args->size() >= 5)) {
HXLINE(  45)				 ::persistence::Persistence _gthis1 = _gthis;
HXDLIN(  45)				resultMapper = _gthis1->convertToHaxe(args->get(4));
            			}
HXLINE(  47)			 ::Dynamic useQueryValuesAsParams = null();
HXLINE(  48)			if ((args->size() >= 6)) {
HXLINE(  49)				useQueryValuesAsParams = ::hx::TCast<  ::maglev::MagLevBoolean >::cast(args->get(5))->getBool();
            			}
HXLINE(  51)			_gthis->addGetter(recordType,operationName,strategyMethod,queryMapper,resultMapper,useQueryValuesAsParams);
HXLINE(  52)			return ::maglev::MagLevResult_obj::fromResult(::maglev::MagLevBoolean_obj::fromBool(true));
            		}
            		HX_END_LOCAL_FUNC1(return)

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_2, ::persistence::Persistence,_gthis) HXARGC(1)
            		 ::maglev::MagLevResult _hx_run( ::maglev::MagLevArray args){
            			HX_GC_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_54_new)
HXLINE(  55)			::String recordType = ::hx::TCast<  ::maglev::MagLevString >::cast(args->get(0))->getString();
HXLINE(  56)			::String operationName = ::hx::TCast<  ::maglev::MagLevString >::cast(args->get(1))->getString();
HXLINE(  57)			 ::persistence::Persistence _gthis1 = _gthis;
HXDLIN(  57)			 ::Dynamic recordData = _gthis1->convertToHaxe(args->get(2));
HXLINE(  58)			 ::persistence::Persistence _gthis2 = _gthis;
HXDLIN(  58)			 ::maglev::MagLevAny ret = _gthis2->convertToMagLev(_gthis->mutate(recordType,operationName,recordData));
HXLINE(  59)			return ::maglev::MagLevResult_obj::fromResult(ret);
            		}
            		HX_END_LOCAL_FUNC1(return)

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_3, ::persistence::Persistence,_gthis) HXARGC(1)
            		 ::maglev::MagLevResult _hx_run( ::maglev::MagLevArray args){
            			HX_GC_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_61_new)
HXLINE(  62)			::String recordType = ::hx::TCast<  ::maglev::MagLevString >::cast(args->get(0))->getString();
HXLINE(  63)			::String operationName = ::hx::TCast<  ::maglev::MagLevString >::cast(args->get(1))->getString();
HXLINE(  64)			 ::persistence::Persistence _gthis1 = _gthis;
HXDLIN(  64)			 ::Dynamic queryValues = _gthis1->convertToHaxe(args->get(2));
HXLINE(  65)			 ::persistence::Persistence _gthis2 = _gthis;
HXDLIN(  65)			 ::maglev::MagLevAny ret = _gthis2->convertToMagLev(_gthis->get(recordType,operationName,queryValues));
HXLINE(  66)			return ::maglev::MagLevResult_obj::fromResult(ret);
            		}
            		HX_END_LOCAL_FUNC1(return)

            	HX_GC_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_16_new)
HXDLIN(  16)		 ::persistence::Persistence _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE(  17)		this->mutators =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  18)		this->getters =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  19)		this->maglev = bus;
HXLINE(  20)		 ::maglev::MagLev _hx_tmp = this->maglev;
HXDLIN(  20)		_hx_tmp->_hx_register(HX_("Persistence.AddMutator",b0,4b,5e,d4),::maglev::MagLevFunction_obj::fromFunction( ::Dynamic(new _hx_Closure_0(_gthis))));
HXLINE(  35)		 ::maglev::MagLev _hx_tmp1 = this->maglev;
HXDLIN(  35)		_hx_tmp1->_hx_register(HX_("Persistence.AddGetter",fd,51,1c,b7),::maglev::MagLevFunction_obj::fromFunction( ::Dynamic(new _hx_Closure_1(_gthis))));
HXLINE(  54)		 ::maglev::MagLev _hx_tmp2 = this->maglev;
HXDLIN(  54)		_hx_tmp2->_hx_register(HX_("Persistence.Mutate",f5,04,66,8c),::maglev::MagLevFunction_obj::fromFunction( ::Dynamic(new _hx_Closure_2(_gthis))));
HXLINE(  61)		 ::maglev::MagLev _hx_tmp3 = this->maglev;
HXDLIN(  61)		_hx_tmp3->_hx_register(HX_("Persistence.Get",c7,c3,56,12),::maglev::MagLevFunction_obj::fromFunction( ::Dynamic(new _hx_Closure_3(_gthis))));
            	}

Dynamic Persistence_obj::__CreateEmpty() { return new Persistence_obj; }

void *Persistence_obj::_hx_vtable = 0;

Dynamic Persistence_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Persistence_obj > _hx_result = new Persistence_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Persistence_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0263bb48;
}

void Persistence_obj::addMutator(::String recordType,::String operationName, ::Dynamic strategyMethod, ::Dynamic updateMapper, ::Dynamic useRecordDataAsParams){
            	HX_GC_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_70_addMutator)
HXLINE(  71)		if (::hx::IsNull( updateMapper )) {
            			HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            			 ::Dynamic _hx_run( ::Dynamic v){
            				HX_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_72_addMutator)
HXLINE(  72)				return v;
            			}
            			HX_END_LOCAL_FUNC1(return)

HXLINE(  72)			updateMapper =  ::Dynamic(new _hx_Closure_0());
            		}
HXLINE(  74)		if (::hx::IsNull( useRecordDataAsParams )) {
HXLINE(  75)			useRecordDataAsParams = false;
            		}
HXLINE(  77)		 ::persistence::_Persistence::Mutator mutator =  ::persistence::_Persistence::Mutator_obj::__alloc( HX_CTX ,recordType,strategyMethod,updateMapper,( (bool)(useRecordDataAsParams) ));
HXLINE(  78)		{
HXLINE(  78)			::Dynamic this1 = this->mutators;
HXDLIN(  78)			( ( ::haxe::ds::StringMap)(this1) )->set(this->calcKey(recordType,operationName),mutator);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(Persistence_obj,addMutator,(void))

void Persistence_obj::addGetter(::String recordType,::String operationName, ::Dynamic strategyMethod, ::Dynamic queryMapper, ::Dynamic resultMapper, ::Dynamic useQueryValuesAsParams){
            	HX_GC_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_81_addGetter)
HXLINE(  82)		if (::hx::IsNull( queryMapper )) {
            			HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            			 ::Dynamic _hx_run( ::Dynamic v){
            				HX_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_83_addGetter)
HXLINE(  83)				return v;
            			}
            			HX_END_LOCAL_FUNC1(return)

HXLINE(  83)			queryMapper =  ::Dynamic(new _hx_Closure_0());
            		}
HXLINE(  85)		if (::hx::IsNull( resultMapper )) {
            			HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_1) HXARGC(1)
            			 ::Dynamic _hx_run( ::Dynamic v){
            				HX_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_86_addGetter)
HXLINE(  86)				return v;
            			}
            			HX_END_LOCAL_FUNC1(return)

HXLINE(  86)			resultMapper =  ::Dynamic(new _hx_Closure_1());
            		}
HXLINE(  88)		if (::hx::IsNull( useQueryValuesAsParams )) {
HXLINE(  89)			useQueryValuesAsParams = false;
            		}
HXLINE(  91)		 ::persistence::_Persistence::Getter getter =  ::persistence::_Persistence::Getter_obj::__alloc( HX_CTX ,recordType,strategyMethod,queryMapper,resultMapper,( (bool)(useQueryValuesAsParams) ));
HXLINE(  92)		{
HXLINE(  92)			::Dynamic this1 = this->getters;
HXDLIN(  92)			( ( ::haxe::ds::StringMap)(this1) )->set(this->calcKey(recordType,operationName),getter);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC6(Persistence_obj,addGetter,(void))

 ::Dynamic Persistence_obj::mutate(::String recordType,::String operationName, ::Dynamic recordData){
            	HX_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_95_mutate)
HXLINE(  96)		::Dynamic this1 = this->mutators;
HXDLIN(  96)		if (( ( ::haxe::ds::StringMap)(this1) )->exists(this->calcKey(recordType,operationName))) {
HXLINE(  97)			::Dynamic this1 = this->mutators;
HXDLIN(  97)			 ::persistence::_Persistence::Mutator mutator = ( ( ::persistence::_Persistence::Mutator)(( ( ::haxe::ds::StringMap)(this1) )->get(this->calcKey(recordType,operationName))) );
HXLINE(  99)			 ::Dynamic params = null();
HXLINE( 100)			if (::Reflect_obj::isFunction(mutator->updateMapper)) {
HXLINE( 101)				 ::Dynamic updateMapper = mutator->updateMapper;
HXLINE( 102)				params = updateMapper(recordData);
            			}
            			else {
HXLINE( 104)				if (::Std_obj::isOfType(mutator->updateMapper,( ( ::Dynamic)(::hx::ClassOf< ::String >()) ))) {
HXLINE( 105)					::String updateMapper = ( (::String)(mutator->updateMapper) );
HXLINE( 107)					 ::maglev::MagLev value = this->maglev;
HXDLIN( 107)					params = value->call(updateMapper,::hx::TCast<  ::maglev::MagLevArray >::cast(this->convertToMagLev(::cpp::VirtualArray_obj::__new(1)->init(0,recordData))));
            				}
            				else {
HXLINE( 110)					HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("updateMapper must be a string or function",e1,0d,80,87)));
            				}
            			}
HXLINE( 113)			 ::Dynamic raw_result = null();
HXLINE( 114)			if (::Reflect_obj::isFunction(mutator->strategyMethod)) {
HXLINE( 115)				 ::Dynamic strategyMethod = mutator->strategyMethod;
HXLINE( 116)				raw_result = strategyMethod(params);
            			}
            			else {
HXLINE( 118)				if (::Std_obj::isOfType(mutator->strategyMethod,( ( ::Dynamic)(::hx::ClassOf< ::String >()) ))) {
HXLINE( 119)					::String strategyMethod = ( (::String)(mutator->strategyMethod) );
HXLINE( 120)					 ::maglev::MagLevResult raw_maglev_result;
HXLINE( 121)					if (mutator->useRecordDataAsParams) {
HXLINE( 122)						 ::maglev::MagLev raw_maglev_result1 = this->maglev;
HXDLIN( 122)						raw_maglev_result = raw_maglev_result1->call(strategyMethod,::hx::TCast<  ::maglev::MagLevArray >::cast(this->convertToMagLev(params)));
            					}
            					else {
HXLINE( 124)						 ::maglev::MagLev raw_maglev_result1 = this->maglev;
HXDLIN( 124)						raw_maglev_result = raw_maglev_result1->call(strategyMethod,::hx::TCast<  ::maglev::MagLevArray >::cast(this->convertToMagLev(::cpp::VirtualArray_obj::__new(1)->init(0,params))));
            					}
HXLINE( 126)					if (raw_maglev_result->isError()) {
HXLINE( 127)						HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(raw_maglev_result->getError()->getMessage()));
            					}
HXLINE( 129)					raw_result = this->convertToHaxe(raw_maglev_result->getResult());
            				}
            				else {
HXLINE( 132)					HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("strategyMethod must be a string or function",97,7a,0d,90)));
            				}
            			}
HXLINE( 135)			return raw_result;
            		}
            		else {
HXLINE( 138)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("the specified mutator has not been added",fc,3b,68,3f)));
            		}
HXLINE(  96)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC3(Persistence_obj,mutate,return )

 ::Dynamic Persistence_obj::get(::String recordType,::String operationName, ::Dynamic queryValues){
            	HX_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_145_get)
HXDLIN( 145)		::Dynamic this1 = this->getters;
HXDLIN( 145)		if (( ( ::haxe::ds::StringMap)(this1) )->exists(this->calcKey(recordType,operationName))) {
HXLINE( 146)			::Dynamic this1 = this->getters;
HXDLIN( 146)			 ::persistence::_Persistence::Getter getter = ( ( ::persistence::_Persistence::Getter)(( ( ::haxe::ds::StringMap)(this1) )->get(this->calcKey(recordType,operationName))) );
HXLINE( 148)			 ::Dynamic query = null();
HXLINE( 149)			if (::Reflect_obj::isFunction(getter->queryMapper)) {
HXLINE( 150)				 ::Dynamic queryMapper = getter->queryMapper;
HXLINE( 151)				query = queryMapper(queryValues);
            			}
            			else {
HXLINE( 153)				if (::Std_obj::isOfType(getter->queryMapper,( ( ::Dynamic)(::hx::ClassOf< ::String >()) ))) {
HXLINE( 154)					::String queryMapper = ( (::String)(getter->queryMapper) );
HXLINE( 156)					 ::maglev::MagLev value = this->maglev;
HXDLIN( 156)					query = value->call(queryMapper,::hx::TCast<  ::maglev::MagLevArray >::cast(this->convertToMagLev(::cpp::VirtualArray_obj::__new(1)->init(0,queryValues))));
            				}
            				else {
HXLINE( 159)					HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("queryMapper must be a string or function",42,16,bc,ef)));
            				}
            			}
HXLINE( 162)			 ::Dynamic raw_result = null();
HXLINE( 163)			if (::Reflect_obj::isFunction(getter->strategyMethod)) {
HXLINE( 164)				 ::Dynamic strategyMethod = getter->strategyMethod;
HXLINE( 165)				raw_result = strategyMethod(query);
            			}
            			else {
HXLINE( 167)				if (::Std_obj::isOfType(getter->strategyMethod,( ( ::Dynamic)(::hx::ClassOf< ::String >()) ))) {
HXLINE( 168)					::String strategyMethod = ( (::String)(getter->strategyMethod) );
HXLINE( 169)					 ::maglev::MagLevResult raw_maglev_result;
HXLINE( 170)					if (getter->useQueryValuesAsParams) {
HXLINE( 171)						 ::maglev::MagLev raw_maglev_result1 = this->maglev;
HXDLIN( 171)						::String getter1 = ( (::String)(getter->strategyMethod) );
HXDLIN( 171)						raw_maglev_result = raw_maglev_result1->call(getter1,::hx::TCast<  ::maglev::MagLevArray >::cast(this->convertToMagLev(query)));
            					}
            					else {
HXLINE( 173)						 ::maglev::MagLev raw_maglev_result1 = this->maglev;
HXDLIN( 173)						::String getter1 = ( (::String)(getter->strategyMethod) );
HXDLIN( 173)						raw_maglev_result = raw_maglev_result1->call(getter1,::hx::TCast<  ::maglev::MagLevArray >::cast(this->convertToMagLev(::cpp::VirtualArray_obj::__new(1)->init(0,query))));
            					}
HXLINE( 175)					if (raw_maglev_result->isError()) {
HXLINE( 176)						HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(raw_maglev_result->getError()->getMessage()));
            					}
HXLINE( 178)					raw_result = this->convertToHaxe(raw_maglev_result->getResult());
            				}
            				else {
HXLINE( 181)					HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("strategyMethod must be a string or function",97,7a,0d,90)));
            				}
            			}
HXLINE( 184)			 ::Dynamic result = null();
HXLINE( 185)			if (::Reflect_obj::isFunction(getter->resultMapper)) {
HXLINE( 186)				 ::Dynamic resultMapper = getter->resultMapper;
HXLINE( 187)				result = resultMapper(raw_result);
            			}
            			else {
HXLINE( 189)				if (::Std_obj::isOfType(getter->resultMapper,( ( ::Dynamic)(::hx::ClassOf< ::String >()) ))) {
HXLINE( 190)					::String resultMapper = ( (::String)(getter->resultMapper) );
HXLINE( 192)					 ::maglev::MagLev maglev_result = this->maglev;
HXDLIN( 192)					 ::maglev::MagLevResult maglev_result1 = maglev_result->call(resultMapper,::hx::TCast<  ::maglev::MagLevArray >::cast(this->convertToMagLev(::cpp::VirtualArray_obj::__new(1)->init(0,raw_result))));
HXLINE( 193)					if (maglev_result1->isError()) {
HXLINE( 194)						HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(maglev_result1->getError()->getMessage()));
            					}
HXLINE( 196)					result = this->convertToHaxe(maglev_result1->getResult());
            				}
            				else {
HXLINE( 199)					HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("resultMapper must be a string or function",8d,d7,71,1d)));
            				}
            			}
HXLINE( 201)			return result;
            		}
            		else {
HXLINE( 204)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("the specified getter has not been added",55,b4,c1,d8)));
            		}
HXLINE( 145)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC3(Persistence_obj,get,return )

::String Persistence_obj::calcKey(::String recordType,::String operationName){
            	HX_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_209_calcKey)
HXDLIN( 209)		return ((recordType + HX_(".",2e,00,00,00)) + operationName);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Persistence_obj,calcKey,return )

 ::Dynamic Persistence_obj::convertToHaxe( ::maglev::MagLevAny x){
            	HX_GC_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_213_convertToHaxe)
HXDLIN( 213)		int _hx_tmp = x->getType();
HXDLIN( 213)		if ((_hx_tmp == ::maglev::MagLevNull_obj::getStaticType())) {
HXLINE( 214)			return null();
            		}
            		else {
HXLINE( 216)			int _hx_tmp = x->getType();
HXDLIN( 216)			if ((_hx_tmp == ::maglev::MagLevBoolean_obj::getStaticType())) {
HXLINE( 217)				 ::maglev::MagLevBoolean y = ::hx::TCast<  ::maglev::MagLevBoolean >::cast(x);
HXLINE( 218)				return y->getBool();
            			}
            			else {
HXLINE( 220)				int _hx_tmp = x->getType();
HXDLIN( 220)				if ((_hx_tmp == ::maglev::MagLevString_obj::getStaticType())) {
HXLINE( 221)					 ::maglev::MagLevString y = ::hx::TCast<  ::maglev::MagLevString >::cast(x);
HXLINE( 222)					return y->getString();
            				}
            				else {
HXLINE( 224)					int _hx_tmp = x->getType();
HXDLIN( 224)					if ((_hx_tmp == ::maglev::MagLevNumber_obj::getStaticType())) {
HXLINE( 225)						 ::maglev::MagLevNumber y = ::hx::TCast<  ::maglev::MagLevNumber >::cast(x);
HXLINE( 226)						return y->getFloat();
            					}
            					else {
HXLINE( 228)						int _hx_tmp = x->getType();
HXDLIN( 228)						if ((_hx_tmp == ::maglev::MagLevArray_obj::getStaticType())) {
HXLINE( 229)							 ::maglev::MagLevArray y = ::hx::TCast<  ::maglev::MagLevArray >::cast(x);
HXLINE( 230)							::cpp::VirtualArray arr = ::cpp::VirtualArray_obj::__new();
HXLINE( 231)							int i = 0;
HXLINE( 232)							while((i < y->size())){
HXLINE( 233)								arr->push(this->convertToHaxe(y->get(i)));
HXLINE( 234)								i = (i + 1);
            							}
HXLINE( 236)							return arr;
            						}
            						else {
HXLINE( 238)							int _hx_tmp = x->getType();
HXDLIN( 238)							if ((_hx_tmp == ::maglev::MagLevObject_obj::getStaticType())) {
HXLINE( 239)								 ::maglev::MagLevObject y = ::hx::TCast<  ::maglev::MagLevObject >::cast(x);
HXLINE( 240)								 ::haxe::ds::StringMap map =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE( 241)								 ::maglev::MagLevArray keys = y->keys();
HXLINE( 242)								int i = 0;
HXLINE( 243)								while((i < keys->size())){
HXLINE( 244)									::String key = ::hx::TCast<  ::maglev::MagLevString >::cast(keys->get(i))->getString();
HXLINE( 245)									map->set(key,this->convertToHaxe(y->get(key)));
HXLINE( 246)									i = (i + 1);
            								}
HXLINE( 248)								return map;
            							}
            							else {
HXLINE( 250)								int _hx_tmp = x->getType();
HXDLIN( 250)								if ((_hx_tmp == ::maglev::MagLevFunction_obj::getStaticType())) {
            									HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_0, ::maglev::MagLevFunction,y, ::persistence::Persistence,o) HXARGC(1)
            									 ::Dynamic _hx_run(::cpp::VirtualArray args){
            										HX_GC_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_253_convertToHaxe)
HXLINE( 254)										 ::maglev::MagLevArray arr = ::maglev::MagLevArray_obj::create();
HXLINE( 255)										{
HXLINE( 255)											int _g = 0;
HXDLIN( 255)											while((_g < args->get_length())){
HXLINE( 255)												 ::Dynamic arg = args->__get(_g);
HXDLIN( 255)												_g = (_g + 1);
HXLINE( 256)												arr->push(o->convertToMagLev(arg));
            											}
            										}
HXLINE( 258)										 ::maglev::MagLevResult ret = y->call(arr);
HXLINE( 259)										if (ret->isError()) {
HXLINE( 260)											HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(ret->getError()->getMessage()));
            										}
            										else {
HXLINE( 262)											 ::persistence::Persistence o1 = o;
HXDLIN( 262)											return o1->convertToHaxe(ret->getResult());
            										}
HXLINE( 259)										return null();
            									}
            									HX_END_LOCAL_FUNC1(return)

HXLINE( 251)									 ::maglev::MagLevFunction y = ::hx::TCast<  ::maglev::MagLevFunction >::cast(x);
HXLINE( 252)									 ::persistence::Persistence o = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 253)									 ::Dynamic f =  ::Dynamic(new _hx_Closure_0(y,o));
HXLINE( 265)									return f;
            								}
            								else {
HXLINE( 268)									HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("convertToHaxe: unknown type",4a,83,07,f2)));
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 213)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Persistence_obj,convertToHaxe,return )

 ::maglev::MagLevAny Persistence_obj::convertToMagLev( ::Dynamic x){
            	HX_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_273_convertToMagLev)
HXDLIN( 273)		if (::hx::IsNull( x )) {
HXLINE( 274)			return ::maglev::MagLevNull_obj::create();
            		}
            		else {
HXLINE( 276)			if (::Std_obj::isOfType(x,( ( ::Dynamic)(::hx::ClassOf< bool >()) ))) {
HXLINE( 277)				return ::maglev::MagLevBoolean_obj::fromBool(::hx::TCast< bool >::cast(x));
            			}
            			else {
HXLINE( 279)				if (::Std_obj::isOfType(x,( ( ::Dynamic)(::hx::ClassOf< ::String >()) ))) {
HXLINE( 280)					return ::maglev::MagLevString_obj::fromString(::hx::TCast< ::String >::cast(x));
            				}
            				else {
HXLINE( 282)					if (::Std_obj::isOfType(x,( ( ::Dynamic)(::hx::ClassOf< int >()) ))) {
HXLINE( 283)						return ::maglev::MagLevNumber_obj::fromInt(::hx::TCast< int >::cast(x));
            					}
            					else {
HXLINE( 285)						if (::Std_obj::isOfType(x,( ( ::Dynamic)(::hx::ClassOf< ::Float >()) ))) {
HXLINE( 286)							return ::maglev::MagLevNumber_obj::fromFloat(( (Float)(x) ));
            						}
            						else {
HXLINE( 288)							if (::Std_obj::isOfType(x,( ( ::Dynamic)(::hx::ArrayBase::__mClass) ))) {
HXLINE( 289)								 ::maglev::MagLevArray arr = ::maglev::MagLevArray_obj::create();
HXLINE( 290)								::cpp::VirtualArray y = ( (::cpp::VirtualArray)(x) );
HXLINE( 291)								{
HXLINE( 291)									int _g = 0;
HXDLIN( 291)									while((_g < y->get_length())){
HXLINE( 291)										 ::Dynamic item = y->__get(_g);
HXDLIN( 291)										_g = (_g + 1);
HXLINE( 292)										arr->push(this->convertToMagLev(item));
            									}
            								}
HXLINE( 294)								return arr;
            							}
            							else {
HXLINE( 296)								if (::Std_obj::isOfType(x,( ( ::Dynamic)(::hx::ClassOf< ::haxe::ds::StringMap >()) ))) {
HXLINE( 297)									 ::haxe::ds::StringMap map = ( ( ::haxe::ds::StringMap)(x) );
HXLINE( 298)									 ::maglev::MagLevObject obj = ::maglev::MagLevObject_obj::create();
HXLINE( 299)									{
HXLINE( 299)										 ::Dynamic key = map->keys();
HXDLIN( 299)										while(( (bool)(key->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 299)											::String key1 = ( (::String)(key->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 300)											obj->set(key1,this->convertToMagLev(map->get(key1)));
            										}
            									}
HXLINE( 302)									return obj;
            								}
            								else {
HXLINE( 304)									if (::Reflect_obj::isObject(x)) {
HXLINE( 305)										 ::maglev::MagLevObject obj = ::maglev::MagLevObject_obj::create();
HXLINE( 306)										{
HXLINE( 306)											int _g = 0;
HXDLIN( 306)											::Array< ::String > _g1 = ::Reflect_obj::fields(x);
HXDLIN( 306)											while((_g < _g1->length)){
HXLINE( 306)												::String field = _g1->__get(_g);
HXDLIN( 306)												_g = (_g + 1);
HXLINE( 307)												 ::Dynamic val = ::Reflect_obj::getProperty(x,field);
HXLINE( 308)												obj->set(field,this->convertToMagLev(val));
            											}
            										}
HXLINE( 310)										return obj;
            									}
            									else {
HXLINE( 312)										if (::Reflect_obj::isFunction(x)) {
HXLINE( 313)											 ::Dynamic f = x;
HXLINE( 314)											return ::maglev::MagLevFunction_obj::fromFunction(f);
            										}
            										else {
HXLINE( 317)											HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("convertToMagLev: unknown type",ae,84,a9,64)));
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 273)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Persistence_obj,convertToMagLev,return )


::hx::ObjectPtr< Persistence_obj > Persistence_obj::__new( ::maglev::MagLev bus) {
	::hx::ObjectPtr< Persistence_obj > __this = new Persistence_obj();
	__this->__construct(bus);
	return __this;
}

::hx::ObjectPtr< Persistence_obj > Persistence_obj::__alloc(::hx::Ctx *_hx_ctx, ::maglev::MagLev bus) {
	Persistence_obj *__this = (Persistence_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Persistence_obj), true, "persistence.Persistence"));
	*(void **)__this = Persistence_obj::_hx_vtable;
	__this->__construct(bus);
	return __this;
}

Persistence_obj::Persistence_obj()
{
}

void Persistence_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Persistence);
	HX_MARK_MEMBER_NAME(mutators,"mutators");
	HX_MARK_MEMBER_NAME(getters,"getters");
	HX_MARK_MEMBER_NAME(maglev,"maglev");
	HX_MARK_END_CLASS();
}

void Persistence_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(mutators,"mutators");
	HX_VISIT_MEMBER_NAME(getters,"getters");
	HX_VISIT_MEMBER_NAME(maglev,"maglev");
}

::hx::Val Persistence_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"get") ) { return ::hx::Val( get_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"maglev") ) { return ::hx::Val( maglev ); }
		if (HX_FIELD_EQ(inName,"mutate") ) { return ::hx::Val( mutate_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"getters") ) { return ::hx::Val( getters ); }
		if (HX_FIELD_EQ(inName,"calcKey") ) { return ::hx::Val( calcKey_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"mutators") ) { return ::hx::Val( mutators ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"addGetter") ) { return ::hx::Val( addGetter_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"addMutator") ) { return ::hx::Val( addMutator_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"convertToHaxe") ) { return ::hx::Val( convertToHaxe_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"convertToMagLev") ) { return ::hx::Val( convertToMagLev_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Persistence_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"maglev") ) { maglev=inValue.Cast<  ::maglev::MagLev >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"getters") ) { getters=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"mutators") ) { mutators=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Persistence_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("mutators",51,5b,0f,e4));
	outFields->push(HX_("getters",08,4b,a3,34));
	outFields->push(HX_("maglev",2a,df,2b,b3));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Persistence_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(Persistence_obj,mutators),HX_("mutators",51,5b,0f,e4)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(Persistence_obj,getters),HX_("getters",08,4b,a3,34)},
	{::hx::fsUnknown /*  ::maglev::MagLev */ ,(int)offsetof(Persistence_obj,maglev),HX_("maglev",2a,df,2b,b3)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Persistence_obj_sStaticStorageInfo = 0;
#endif

static ::String Persistence_obj_sMemberFields[] = {
	HX_("mutators",51,5b,0f,e4),
	HX_("getters",08,4b,a3,34),
	HX_("maglev",2a,df,2b,b3),
	HX_("addMutator",c1,56,e0,ee),
	HX_("addGetter",0c,14,64,5b),
	HX_("mutate",86,f3,be,3f),
	HX_("get",96,80,4e,00),
	HX_("calcKey",0a,f4,5a,4e),
	HX_("convertToHaxe",94,89,1b,b6),
	HX_("convertToMagLev",f8,a3,b9,0f),
	::String(null()) };

::hx::Class Persistence_obj::__mClass;

void Persistence_obj::__register()
{
	Persistence_obj _hx_dummy;
	Persistence_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("persistence.Persistence",b0,8b,d5,e5);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Persistence_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Persistence_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Persistence_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Persistence_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Persistence_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_9b0a59171cb4a4c9_10_boot)
HXDLIN(  10)		__mClass->__meta__ =  ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("obj",f7,8f,54,00), ::Dynamic(::hx::Anon_obj::Create(1)
            				->setFixed(0,HX_("SuppressWarnings",0c,d3,d2,00),::cpp::VirtualArray_obj::__new(1)->init(0,::cpp::VirtualArray_obj::__new(4)->init(0,HX_("checkstyle:FieldDocComment",70,56,1b,20))->init(1,HX_("checkstyle:LocalVariableName",c1,ac,a3,03))->init(2,HX_("checkstyle:MultipleStringLiterals",d6,ed,13,79))->init(3,HX_("checkstyle:MagicNumber",a5,aa,f4,8b)))))));
            	}
}

} // end namespace persistence
